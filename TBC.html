<!DOCTYPE HTML>
<HTML>
<HEAD>
	<TITLE>To Be Continued</TITLE>
</HEAD>
<BODY>
	<P>
		• Adequar template e retirar quebras de linha entre parágrafos. Adicionar lista de figuras.
		
		A seção "Managers" é composta por três scripts gerenciadores, isto é, eles tem o propósito de controlar fluxos dentro do jogo, e estão atrelados a objetos invisíveis dentro do jogo, meramente respondendo a quando são requisitados.
		
		Com isso, começamos pelo BattleManager, isto é, o gerenciador de batalhas. Ele possui um método Awake, que inicializa o inimigo no mapa em uma posição aleatória dentro de um alcance especificado, e um método CheckBattleConditions, que finaliza a batalha quando não existem mais inimigos vivos no mapa. Ele é relativamente simples, porém, pode ser utilizado para outras coisas, como controlar um menu de pausa, dar ao jogador a opção de tentar novamente ao ser derrotado, entre outras.
		
		Em seguida, temos o DialogueManager, o gerenciador de diálogos. Ele é utilizado para controlar a sequência de diálogos que ocorrem entre o jogador e os diversos NPCs que possam ser utilizados. O protótipo faz uso de apenas um, fora do cenário de combate. Possui um método StartDialogue, que serve para buscar e enfileirar as frases, congelar a movimentação do jogador e exibir a caixa de diálogo. 
		
		Temos também um método TypeSentence, que faz com que as letras do diálogo sejam preenchidas ao longo do tempo, gerando um efeito semelhante à digitação, um método QueueNextSentence, que busca e exibe a próxima frase da fila e exibe ao pressionar a tecla designada para isso, e o método EndDialogue, que é utilizado para descongelar o movimento do jogador e esconder a caixa de diálogo.
		
		O último gerenciador utilizado chama-se GameManager, e ele é voltado para controlar mecanismos que precisamos manter em observação durante a transição de cenas. Isto é, ele grava a posição em que o jogador estava ao entrar em combate, a quantidade de criaturas vivas no cenário principal, é responsável por inicializar as criaturas ao carregar o cenário, e controlar o carregamento de cenários.
		
		Como podemos ver, os gerenciadores são responsáveis por controlar comportamentos que não estão associados a nenhum objeto em específico nos cenários, motivo pelo qual possuem scripts segregados dos demais. Tecnicamente é possível implementar esses mesmos mecanismos em scripts de outros objetos, mas isso geraria uma grande quantidade de código duplicado, dificultando a manutenção e aumentando a propensão a erros.
		
		Os scripts "CameraMovement" e "SidescrollerCamera" tem o mesmo propósito, porém em pontos de vista diferentes. A câmera pode ser interpretada como o ponto de onde observamos o jogo acontecer. Quando observamos um cenário se mover junto ao nosso personagem, estamos observando a câmera se mover para acompanhar seu movimento, efetivamente nos permitindo observar o que há além do quadrado inicial que observamos ao começar. Se a câmera fosse estática e nos deslocassemos para além de seu alcance, conseguiriamos continuar movimentando o personagem, mas seria difícil determinar sua posição, tornando a experiência de jogo ruim.
		
		Assim, para permitir que o cenário seja percorrido de maneira intuitiva, fazemos com que a câmera persiga o personagem controlável, através de uma função matemática de interpolação linear, acessível através de uma das classes vetoriais do Unity. O objetivo da interpolação é fazer com que a movimentação seja gradativa, tornando-a mais suave e natural. Visto que temos dois cenários, cada um com sua própria câmera, cada uma tem seu próprio script para permitir tratamentos específicos levando em consideração o plano que cada uma observa, isto é, se visto de cima ou lateralmente.
		
		Outro detalhe importante é que não devemos permitir que a câmera escape de suas delimitações, pois isso pode fazer com que o jogador enxergue elementos que não deveriam estar em cena. Para isso delimitamos um limite superior esquerdo, e outro inferior direito, que delimitam até onde a câmera pode percorrer. Sendo assim, caso o jogador alcance o limite do cenário, a câmera terá sua movimentação corrigida, evitando que escape das bordas.
		
		--Atualizar último parágrafo e adicionar seguintes!
		
		Foi necessária a criação de alguns scripts para comportamentos gerais, que não necessariamente se enquadram em alguma categoria no jogo. Um deles é o DialogueTrigger, que contém o gatilho para iniciar o diálogo. O script verifica se o jogador está dentro da área de interação com o NPC, e caso esteja, dará início à conversa fazendo uso do DialogueManager. Esse mesmo script pode ser associado a diversos objetos para obter o comportamento esperado, alterando-se apenas os diálogos associados a ele. O mesmo acontece com scripts associados a criaturas e alguns objetos, como é o caso do MapChange, utilizado para transição entre áreas do jogo.
		
		Conforme mencionado, a câmera seguirá o jogador somente até as bordas de determinada área do jogo para evitar mostrar seções vazias do cenário. Contudo, para dividir as áreas de acordo com sua temática, optei por uma divisão semelhante à utilizada na série de jogos 2D [The Legend Of Zelda], onde, ao chegar na borda que divide duas áreas, a câmera se reajusta à nova área acessada e o jogador é posicionado à frente para evitar problemas de transição. O script MapChange tem exatamente o propósito de reorientar a câmera e mover o jogador, utilizando uma caixa de colisão de um dos componentes do Unity, "BoxCollider2D", para detectar quando o jogador entrou na área de transição. Para isso, associamos o script a um objeto invisível que possui o componente e fica na transição entre duas áreas. É importante notar que para a transição ocorrer no sentido oposto deve existir outro objeto dentro da área acessada, com os parâmetros necessários para retornar a câmera e o jogador para as posições adequadas.
		
		Outro script de comportamento geral é o SortWithPlayer, que tem como objetivo exibir os objetos na camada correta. Para isso, precisamos ter a percepção de que o jogo 2D é desenhado em camadas, isto é, primeiro é desenhado o fundo, então é desenhado o chão, aí são desenhados os objetos que estão acima do chão, e então aqueles que por ventura possam estar acima de tais objetos. Por padrão, o Unity possui uma estruturação em camadas que nos permite dizer onde cada parte do cenário será desenhada, e isso resolve o problema inicial. Porém, isso muda quando temos objetos em movimento, como por exemplo, o nosso personagem jogável.
		
		Isto se torna um problema pois ele pode estar à frente ou atrás de determinados objetos no cenário, e caso não façamos a alteração da camada onde ele deve ser desenhado, teremos comportamentos indesejados onde o jogador será exibido em um local onde não deveria. Para solucionar o problema, o script SortWithPlayer é incorporado a cada objeto onde o jogador pode se esconder, e cada um deles faz uma comparação com a posição vertical do jogador para decidir em qual camada será desenhado. Com isso, conseguimos contornar objetos como casas e torres, que possuem altura suficiente para permitir que passemos por trás de suas estruturas sem enxergarmos o personagem.
		
		Para o personagem em si, temos quatro scripts diferentes para controlar alguns comportamentos associados a ele. O SidescrollerMovement, que lida com a movimentação do cenário de combate, o PlayerMovement, que lida com a movimentação do cenário principal, o PlayerAttack, que lida com o sistema de ataques no combate, e o HealthController, que lida com os pontos de vida.
		
		Para o cenário principal, temos apenas o script PlayerMovement. Ele é composto pelos métodos Start, Update, FixedUpdate e AnimationControl, onde os três primeiros são herdados da classe MonoBehaviour. No método start buscamos os componentes associados ao personagem, e posicionamos ele de acordo com as últimas coordenadas armazenadas no GameManager, caso existam. O método Update é utilizado para verificar se estamos pressionando a tecla de correr, e se estivermos, multiplicará a velocidade de movimentação por 2.
		
		O FixedUpdate é um método semelhante ao Update, com a diferença de que é atualizado com menor frequência, especificamente quando as bibliotecas de física da IDE são validadas, isto é, quando funções de física são calculadas. Ele é útil pois estamos controlando a movimentação do personagem com um componente chamado [RigidBody2D], que é um componente que utiliza conceitos como aceleração, gravidade, atrito, entre outros. Nesse caso, estamos utilizando apenas a aceleração, para ditar o quão rápido nos deslocamos de acordo com as teclas direcionais pressionadas. Também fazemos a chamada do método AnimationControl, que é responsável por enviar os comandos à nossa árvore de animações para que se atualize de acordo com as teclas pressionadas. Para esse script, é possível se mover nas oito direções cardinais com a mesma velocidade.
		
		O script SidescrollerMovement é bem semelhante ao anterior, com a diferença de que é possível mover-se apenas lateralmente, além de pular. Como no script anterior, é composto também dos métodos Start, Update e FixedUpdate, porém, possui também os métodos KnockBackPlayer, RecoverFromKB, FlipCharacter e JumpControl.
		
		Como anteriormente, o método Start é utilizado para buscar os componentes, e nesse caso nada além disso. O Update faz uma verificação semelhante da tecla de corrida para multiplicar a velocidade de movimento, e possui uma chamada ao método JumpControl, que é responsável por controlar o pulo do personagem.
		
		O JumpControl verifica se o personagem está no chão e se a tecla de pular está sendo pressionada, e caso as condições sejam atendidas acelera o personagem verticalmente para cima até a tecla de pular ser largada ou até que a altura limite de pulo, medida pelo tempo desde que o pulo foi iniciado, seja alcançada. Nesse caso, estamos utilizando a gravidade do componente [RigidBody2D], que desacelera gradativamente o pulo do personagem até que volte a cair. A forma como o pulo é controlado fornece maior controle ao jogador, que pode escolher executar pulos menores para se posicionar de maneira mais confortável.
		
		O método FlipCharacter é utilizado apenas para espelhar o [sprite] do personagem de acordo com a direção em que está se movendo, reduzindo pela metade a quantidade de imagens necessárias para exibir todas as animações existentes.
		
		Os métodos KnockBackPlayer e RecoverFromKB são partes do mesmo mecanismo, que servem para empurrar o personagem caso entre em colisão com um inimigo, fazendo utilização do Enum HitDirection para determinar qual a direção em que será empurrado, e congelando sua movimentação temporariamente. É utilizado o componente [RigidBody2D] para adicionar uma força de impulso no momento da colisão, e a função KnockBackPlayer é chamada pelo inimigo com o qual colide, como visto adiante.
		
		O script HealthController é relativamente simples, visto que o único propósito é controlar os pontos de vida do personagem. Possui os métodos Start, Update, Die, TakeDamage, CanTakeDamage e IsAlive.
		
		O método Start inicializa os pontos de vida do personagem durante o combate, além de buscar os componentes associados a ele. O método Update monitora a vida atual para saber se estão abaixo de zero, e caso estejam, executará a animação de morte, apagando o objeto do jogador, resultando em uma condição de fim de jogo.
		
		O método TakeDamage é chamado no momento que o personagem é atacado por um inimigo, e executa a animação "Hurt", além de reduzir os pontos de vida atuais. Toda vez que o personagem tem seus pontos de vida, ganha um curto período de invulnerabilidade, onde não pode ser danificado novamente. O método CanTakeDamage nos diz se ele ainda está nesse período de invulnerabilidade ou não, e ele é verificado toda vez que um inimigo tenta atingir o jogador.
		
		O método IsAlive verifica se o jogador está vivo, e seu propósito é evitar erros ao tentar acessar um objeto destruído. Essa é uma preocupação necessária, uma vez que o jogo pode travar ou gerar comportamentos inesperados quando tentamos executar um comportamento que deveria ocorrer apenas quando o personagem está vivo.
		
		Por fim, temos o script PlayerAttack, que controla todos os golpes desferidos pelo jogador. É composto pelos métodos Start, Update, ManageAttacks e AttackEnemy, além de um método utilitário da IDE chamado OnDrawGizmosSelected, que nos auxilia a observar a área de efeito dos golpes.
		
		Nesse script, implementei um sistema de combos, isto é, ataques em sucessão, utilizando a classe Combo. A ideia é que, ao executar três ataques em rápida sucessão, cada golpe consecutivo tenha um dano proporcionalmente maior, efetivamente criando um combo de três golpes. Para tal, é informada uma janela de tempo dentro da qual o próximo golpe deve ser desferido para fazer parte do combo.
		
		O método Start é responsável por gerar a lista de golpes do combo, onde é informado o multiplicador de dano, um alcance de dano adicional somado, e o tempo mínimo de "resfriamento" entre golpes. O tempo de resfriamento é necessário para impedir que sejam desferidos golpes muito rapidamente, trivializando combates ao pressionar o botão de ataque muito rapidamente. Sendo assim, após desferir um determinado golpe, seria necessário atacar novamente numa janela de, por exemplo, 0.3 segundo até 1 segundo para dar continuidade à sequência.
		
		O método Update serve para reiniciar o combo caso o próximo ataque não seja executado a tempo, e executar o ataque caso a tecla associada seja pressionada e o tempo de resfriamento não seja maior do que zero, através da chamada do método ManageAttacks.
		
		O ManageAttacks, por sua vez, verifica em qual etapa do combo estamos, busca as informações referentes ao golpe seguinte e faz a chamada do método AttackEnemy, passando as informações necessárias. Ali, ele verifica todos os inimigos que estão dentro do raio de ataque e chama o o método TakeDamage do script EnemyController visto adiante, além de enviar os comandos para a árvore de animações do personagem referentes ao golpe executado. E com isso, vimos todos os mecanismos executados pelo jogador.
		
		Como podemos observar, existe uma série de comportamentos que precisamos associar ao jogador, que é o meio pelo qual interagimos com o jogo. Veremos que o inimigo terá uma quantidade semelhante de comportamentos, pois é controlado por uma inteligência artificial, e é dotado de todas as capacidades necessárias para ser controlado por um ser humano. Isso é um fato interessante ao estudarmos a utilização de IAs, pois percebemos que muitas vezes acessamos aos mesmos mecanismos, e muitas das etapas são semelhantes.
		
		Para as criaturas, temos a categoria Enemy, que representa todos os scripts referentes a inimigos. Isso inclui o OverworldEnemyController, o InitBattle, o EnemyController e a SampleEnemyTree. Os dois primeiros estão associados ao inimigo no cenário principal, enquanto os dois últimos estão associados ao cenário de combate.
		
		É aqui que entram os scripts que fazem uso das técnicas de inteligência artificial, além dos comportamentos básicos que precisam ser retornados como resultado das tomadas de decisão decorrentes da utilização delas.
		
		O script InitBattle é o mais simples deles, cujo único propósito é criar a transição de cenários decorrente da colisão com o jogador. Antes de executar a transição, ele faz uma chamada ao GameManager para armazenar a posição do jogador e gravar o identificador de qual inimigo está sendo enfrentado, para que seja excluído quando for derrotado.
		
		O script InitBattle é o mais simples deles, cujo único propósito é criar a transição de cenários decorrente da colisão com o jogador. Antes de executar a transição, ele faz uma chamada ao GameManager para armazenar a posição do jogador e gravar o identificador de qual inimigo está sendo enfrentado, para que seja excluído quando for derrotado.

		Aqui temos a primeira instância de um script que faz uso de uma das técnicas, nesse caso, a árvore de comportamento. O OverworldEnemyController é um script com 6 métodos: Start, Update, HandlePathfinding, OnPathFound, FollowPath e OnDrawGizmos. Novamente, os métodos Start, Update e OnDrawGizmos são herdados da classe MonoBehaviour, e o restante faz uso do algoritmo de pathfinding.
	</P>
	<SCRIPT>
		document.onload = function()
		{
			alert("Hey! Listen! Watch out!");
		};
	</SCRIPT>
</BODY>
</HTML>
