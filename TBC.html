<!DOCTYPE HTML>
<HTML>
<HEAD>
	<TITLE>To Be Continued</TITLE>
</HEAD>
<BODY>
	<P>
		• Adequar template e retirar quebras de linha entre parágrafos. Adicionar lista de figuras.
		
		A seção "Managers" é composta por três scripts gerenciadores, isto é, eles tem o propósito de controlar fluxos dentro do jogo, e estão atrelados a objetos invisíveis dentro do jogo, meramente respondendo a quando são requisitados.
		
		Com isso, começamos pelo BattleManager, isto é, o gerenciador de batalhas. Ele possui um método Awake, que inicializa o inimigo no mapa em uma posição aleatória dentro de um alcance especificado, e um método CheckBattleConditions, que finaliza a batalha quando não existem mais inimigos vivos no mapa. Ele é relativamente simples, porém, pode ser utilizado para outras coisas, como controlar um menu de pausa, dar ao jogador a opção de tentar novamente ao ser derrotado, entre outras.
		
		Em seguida, temos o DialogueManager, o gerenciador de diálogos. Ele é utilizado para controlar a sequência de diálogos que ocorrem entre o jogador e os diversos NPCs que possam ser utilizados. O protótipo faz uso de apenas um, fora do cenário de combate. Possui um método StartDialogue, que serve para buscar e enfileirar as frases, congelar a movimentação do jogador e exibir a caixa de diálogo. 
		
		Temos também um método TypeSentence, que faz com que as letras do diálogo sejam preenchidas ao longo do tempo, gerando um efeito semelhante à digitação, um método QueueNextSentence, que busca e exibe a próxima frase da fila e exibe ao pressionar a tecla designada para isso, e o método EndDialogue, que é utilizado para descongelar o movimento do jogador e esconder a caixa de diálogo.
		
		O último gerenciador utilizado chama-se GameManager, e ele é voltado para controlar mecanismos que precisamos manter em observação durante a transição de cenas. Isto é, ele grava a posição em que o jogador estava ao entrar em combate, a quantidade de criaturas vivas no cenário principal, é responsável por inicializar as criaturas ao carregar o cenário, e controlar o carregamento de cenários.
		
		Como podemos ver, os gerenciadores são responsáveis por controlar comportamentos que não estão associados a nenhum objeto em específico nos cenários, motivo pelo qual possuem scripts segregados dos demais. Tecnicamente é possível implementar esses mesmos mecanismos em scripts de outros objetos, mas isso geraria uma grande quantidade de código duplicado, dificultando a manutenção e aumentando a propensão a erros.
		
		Os scripts "CameraMovement" e "SidescrollerCamera" tem o mesmo propósito, porém em pontos de vista diferentes. A câmera pode ser interpretada como o ponto de onde observamos o jogo acontecer. Quando observamos um cenário se mover junto ao nosso personagem, estamos observando a câmera se mover para acompanhar seu movimento, efetivamente nos permitindo observar o que há além do quadrado inicial que observamos ao começar. Se a câmera fosse estática e nos deslocassemos para além de seu alcance, conseguiriamos continuar movimentando o personagem, mas seria difícil determinar sua posição, tornando a experiência de jogo ruim.
		
		Assim, para permitir que o cenário seja percorrido de maneira intuitiva, fazemos com que a câmera persiga o personagem controlável, através de uma função matemática de interpolação linear, acessível através de uma das classes vetoriais do Unity. O objetivo da interpolação é fazer com que a movimentação seja gradativa, tornando-a mais suave e natural. Visto que temos dois cenários, cada um com sua própria câmera, cada uma tem seu próprio script para permitir tratamentos específicos levando em consideração o plano que cada uma observa, isto é, se visto de cima ou lateralmente.
		
		Outro detalhe importante é que não devemos permitir que a câmera escape de suas delimitações, pois isso pode fazer com que o jogador enxergue elementos que não deveriam estar em cena. Para isso delimitamos um limite superior esquerdo, e outro inferior direito, que delimitam até onde a câmera pode percorrer. Sendo assim, caso o jogador alcance o limite do cenário, a câmera terá sua movimentação corrigida, evitando que escape das bordas.
		
		--Atualizar último parágrafo e adicionar seguintes!
		
		Foi necessária a criação de alguns scripts para comportamentos gerais, que não necessariamente se enquadram em alguma categoria no jogo. Um deles é o DialogueTrigger, que contém o gatilho para iniciar o diálogo. O script verifica se o jogador está dentro da área de interação com o NPC, e caso esteja, dará início à conversa fazendo uso do DialogueManager. Esse mesmo script pode ser associado a diversos objetos para obter o comportamento esperado, alterando-se apenas os diálogos associados a ele. O mesmo acontece com scripts associados a criaturas e alguns objetos, como é o caso do MapChange, utilizado para transição entre áreas do jogo.
		
		Conforme mencionado, a câmera seguirá o jogador somente até as bordas de determinada área do jogo para evitar mostrar seções vazias do cenário. Contudo, para dividir as áreas de acordo com sua temática, optei por uma divisão semelhante à utilizada na série de jogos 2D [The Legend Of Zelda], onde, ao chegar na borda que divide duas áreas, a câmera se reajusta à nova área acessada e o jogador é posicionado à frente para evitar problemas de transição. O script MapChange tem exatamente o propósito de reorientar a câmera e mover o jogador, utilizando uma caixa de colisão de um dos componentes do Unity, "BoxCollider2D", para detectar quando o jogador entrou na área de transição. Para isso, associamos o script a um objeto invisível que possui o componente e fica na transição entre duas áreas. É importante notar que para a transição ocorrer no sentido oposto deve existir outro objeto dentro da área acessada, com os parâmetros necessários para retornar a câmera e o jogador para as posições adequadas.
		
		Outro script de comportamento geral é o SortWithPlayer, que tem como objetivo exibir os objetos na camada correta. Para isso, precisamos ter a percepção de que o jogo 2D é desenhado em camadas, isto é, primeiro é desenhado o fundo, então é desenhado o chão, aí são desenhados os objetos que estão acima do chão, e então aqueles que por ventura possam estar acima de tais objetos. Por padrão, o Unity possui uma estruturação em camadas que nos permite dizer onde cada parte do cenário será desenhada, e isso resolve o problema inicial. Porém, isso muda quando temos objetos em movimento, como por exemplo, o nosso personagem jogável.
		
		Isto se torna um problema pois ele pode estar à frente ou atrás de determinados objetos no cenário, e caso não façamos a alteração da camada onde ele deve ser desenhado, teremos comportamentos indesejados onde o jogador será exibido em um local onde não deveria. Para solucionar o problema, o script SortWithPlayer é incorporado a cada objeto onde o jogador pode se esconder, e cada um deles faz uma comparação com a posição vertical do jogador para decidir em qual camada será desenhado. Com isso, conseguimos contornar objetos como casas e torres, que possuem altura suficiente para permitir que passemos por trás de suas estruturas sem enxergarmos o personagem.
		
		Para o personagem em si, temos quatro scripts diferentes para controlar alguns comportamentos associados a ele. O SidescrollerMovement, que lida com a movimentação do cenário de combate, o PlayerMovement, que lida com a movimentação do cenário principal, o PlayerAttack, que lida com o sistema de ataques no combate, e o HealthController, que lida com os pontos de vida.
		
		Para o cenário principal, temos apenas o script PlayerMovement. Ele é composto pelos métodos Start, Update, FixedUpdate e AnimationControl, onde os três primeiros são herdados da classe MonoBehaviour. No método start buscamos os componentes associados ao personagem, e posicionamos ele de acordo com as últimas coordenadas armazenadas no GameManager, caso existam. O método Update é utilizado para verificar se estamos pressionando a tecla de correr, e se estivermos, multiplicará a velocidade de movimentação por 2.
		
		O FixedUpdate é um método semelhante ao Update, com a diferença de que é atualizado com menor frequência, especificamente quando as bibliotecas de física da IDE são validadas, isto é, quando funções de física são calculadas. Ele é útil pois estamos controlando a movimentação do personagem com um componente chamado [RigidBody2D], que é um componente que utiliza conceitos como aceleração, gravidade, atrito, entre outros. Nesse caso, estamos utilizando apenas a aceleração, para ditar o quão rápido nos deslocamos de acordo com as teclas direcionais pressionadas. Também fazemos a chamada do método AnimationControl, que é responsável por enviar os comandos à nossa árvore de animações para que se atualize de acordo com as teclas pressionadas. Para esse script, é possível se mover nas oito direções cardinais com a mesma velocidade.
		
		O script SidescrollerMovement é bem semelhante ao anterior, com a diferença de que é possível mover-se apenas lateralmente, além de pular. Como no script anterior, é composto também dos métodos Start, Update e FixedUpdate, porém, possui também os métodos KnockBackPlayer, RecoverFromKB, FlipCharacter e JumpControl.
		
		Como anteriormente, o método Start é utilizado para buscar os componentes, e nesse caso nada além disso. O Update faz uma verificação semelhante da tecla de corrida para multiplicar a velocidade de movimento, e possui uma chamada ao método JumpControl, que é responsável por controlar o pulo do personagem.
		
		O JumpControl verifica se o personagem está no chão e se a tecla de pular está sendo pressionada, e caso as condições sejam atendidas acelera o personagem verticalmente para cima até a tecla de pular ser largada ou até que a altura limite de pulo, medida pelo tempo desde que o pulo foi iniciado, seja alcançada. Nesse caso, estamos utilizando a gravidade do componente [RigidBody2D], que desacelera gradativamente o pulo do personagem até que volte a cair. A forma como o pulo é controlado fornece maior controle ao jogador, que pode escolher executar pulos menores para se posicionar de maneira mais confortável.
		
		O método FlipCharacter é utilizado apenas para espelhar o [sprite] do personagem de acordo com a direção em que está se movendo, reduzindo pela metade a quantidade de imagens necessárias para exibir todas as animações existentes.
		
		Os métodos KnockBackPlayer e RecoverFromKB são partes do mesmo mecanismo, que servem para empurrar o personagem caso entre em colisão com um inimigo, fazendo utilização do Enum HitDirection para determinar qual a direção em que será empurrado, e congelando sua movimentação temporariamente. É utilizado o componente [RigidBody2D] para adicionar uma força de impulso no momento da colisão, e a função KnockBackPlayer é chamada pelo inimigo com o qual colide, como visto adiante.
		
		O script HealthController é relativamente simples, visto que o único propósito é controlar os pontos de vida do personagem. Possui os métodos Start, Update, Die, TakeDamage, CanTakeDamage e IsAlive.
		
		O método Start inicializa os pontos de vida do personagem durante o combate, além de buscar os componentes associados a ele. O método Update monitora a vida atual para saber se estão abaixo de zero, e caso estejam, executará a animação de morte, apagando o objeto do jogador, resultando em uma condição de fim de jogo.
		
		O método TakeDamage é chamado no momento que o personagem é atacado por um inimigo, e executa a animação "Hurt", além de reduzir os pontos de vida atuais. Toda vez que o personagem tem seus pontos de vida, ganha um curto período de invulnerabilidade, onde não pode ser danificado novamente. O método CanTakeDamage nos diz se ele ainda está nesse período de invulnerabilidade ou não, e ele é verificado toda vez que um inimigo tenta atingir o jogador.
		
		O método IsAlive verifica se o jogador está vivo, e seu propósito é evitar erros ao tentar acessar um objeto destruído. Essa é uma preocupação necessária, uma vez que o jogo pode travar ou gerar comportamentos inesperados quando tentamos executar um comportamento que deveria ocorrer apenas quando o personagem está vivo.
		
		Por fim, temos o script PlayerAttack, que controla todos os golpes desferidos pelo jogador. É composto pelos métodos Start, Update, ManageAttacks e AttackEnemy, além de um método utilitário da IDE chamado OnDrawGizmosSelected, que nos auxilia a observar a área de efeito dos golpes.
		
		Nesse script, implementei um sistema de combos, isto é, ataques em sucessão, utilizando a classe Combo. A ideia é que, ao executar três ataques em rápida sucessão, cada golpe consecutivo tenha um dano proporcionalmente maior, efetivamente criando um combo de três golpes. Para tal, é informada uma janela de tempo dentro da qual o próximo golpe deve ser desferido para fazer parte do combo.
		
		O método Start é responsável por gerar a lista de golpes do combo, onde é informado o multiplicador de dano, um alcance de dano adicional somado, e o tempo mínimo de "resfriamento" entre golpes. O tempo de resfriamento é necessário para impedir que sejam desferidos golpes muito rapidamente, trivializando combates ao pressionar o botão de ataque muito rapidamente. Sendo assim, após desferir um determinado golpe, seria necessário atacar novamente numa janela de, por exemplo, 0.3 segundo até 1 segundo para dar continuidade à sequência.
		
		O método Update serve para reiniciar o combo caso o próximo ataque não seja executado a tempo, e executar o ataque caso a tecla associada seja pressionada e o tempo de resfriamento não seja maior do que zero, através da chamada do método ManageAttacks.
		
		O ManageAttacks, por sua vez, verifica em qual etapa do combo estamos, busca as informações referentes ao golpe seguinte e faz a chamada do método AttackEnemy, passando as informações necessárias. Ali, ele verifica todos os inimigos que estão dentro do raio de ataque e chama o o método TakeDamage do script EnemyController visto adiante, além de enviar os comandos para a árvore de animações do personagem referentes ao golpe executado. E com isso, vimos todos os mecanismos executados pelo jogador.
		
		Como podemos observar, existe uma série de comportamentos que precisamos associar ao jogador, que é o meio pelo qual interagimos com o jogo. Veremos que o inimigo terá uma quantidade semelhante de comportamentos, pois é controlado por uma inteligência artificial, e é dotado de todas as capacidades necessárias para ser controlado por um ser humano. Isso é um fato interessante ao estudarmos a utilização de IAs, pois percebemos que muitas vezes acessamos aos mesmos mecanismos, e muitas das etapas são semelhantes.
		
		Para as criaturas, temos a categoria Enemy, que representa todos os scripts referentes a inimigos. Isso inclui o OverworldEnemyController, o InitBattle, o EnemyController e a SampleEnemyTree. Os dois primeiros estão associados ao inimigo no cenário principal, enquanto os dois últimos estão associados ao cenário de combate.
		
		É aqui que entram os scripts que fazem uso das técnicas de inteligência artificial, além dos comportamentos básicos que precisam ser retornados como resultado das tomadas de decisão decorrentes da utilização delas.
		
		O script InitBattle é o mais simples deles, cujo único propósito é criar a transição de cenários decorrente da colisão com o jogador. Antes de executar a transição, ele faz uma chamada ao GameManager para armazenar a posição do jogador e gravar o identificador de qual inimigo está sendo enfrentado, para que seja excluído quando for derrotado.

		Aqui temos a primeira instância de um script que faz uso de uma das técnicas abordadas, nesse caso, o pathfinding. O OverworldEnemyController é um script com 6 métodos: Start, Update, HandlePathfinding, OnPathFound, FollowPath e OnDrawGizmos. Novamente, os métodos Start, Update e OnDrawGizmos são herdados da classe MonoBehaviour, e o restante faz uso do algoritmo de pathfinding.
		
		Mais uma vez, o método Start é usado para buscar referência de componentes, e nesse caso, para buscar e armazenar em uma variável o componente Transform do personagem jogável, que contém as coordenadas de sua posição. O método Update é utilizado para chamar o HandlePathfinding a cada 20 frames, e o método OnDrawGizmos é utilizado para traçar, dentro do editor, o caminho calculado pelo algoritmo.
		
		O método HandlePathfinding calcula a distância entre o inimigo e o jogador, e caso ele esteja dentro do raio de alcance de sua visão, fará uma requisição ao script PathRequestManager, que, ao final de sua execução, chamará a função callback OnPathFound. Chamamos de callback as funções que são executadas ao final de alguma execução ou verificação, nesse caso, é a função que é executada após o método RequestPath chamado dentro do PathRequestManager.
		
		O método OnPathFound verifica se existe uma rota acessível até o seu destino, e caso exista, executa a função FollowPath, que utiliza a lista de vetores recebida do PathRequestManager para determinar o caminho que deve seguir. Por vetor, entenda o conceito matemático de vetor, que representa uma reta em determinado plano que é orientada em determinado sentido, representando um caminho a ser traçado. Uma lista de vetores representa uma série de linhas retas a serem percorridas até o destino final.
		
		O comportamento de perseguição acima, somado ao início do combate na existência de colisões com o jogador, satisfazem as características esperadas das criaturas no cenário principal. Havendo o início do combate, gerenciado pelo BattleManager, passamos a observar os scripts EnemyController e SampleEnemyTree, que implementam uma árvore de comportamento e executam os comportamentos resultantes de sua avaliação. Para tal, podemos nos referir à figura X para observar a estrutura da árvore implementada.
		
		Assim, para o EnemyController temos os métodos Start, Update, Die, MoveTowardsPlayer, RunAway, AttackPlayer, AttackPlayerDelayed, OnCollisionEntender2D, KnockbackPlayer, TakeDamage, GetCurrentHealth, GetCurrentCooldown, DamageBlink e OnDrawGizmosSelected. Para o SampleEnemyTree, que representa a árvore de comportamento estruturada, temos Start, LoadDependencies, Evaluate, ExecuteActions, MoveTowardsPlayer, RunAway, AttackPlayer, WithinAtkRange, HealthSafeZone e AttackOffCooldown.
		
		Fica evidente que para replicar os diversos comportamentos esperados de uma inteligência artificial é necessário prover diversas ferramentas, nesse caso, os métodos, que representam ações que podem ser executadas pela criatura. Ela pode se aproximar do jogador, correr dele, atacar o jogador e morrer. Ela também faz uma série de verificações para permitir sua tomada de decisões, e notamos que muitos métodos tem a mesma nomenclatura entre os dois scripts. Vamos ver caso a caso, começando pelo script da árvore, SampleEnemyTree.
		
		Novamente, o método Start é usado para buscar os componentes, dessa vez através da chamada do método LoadDependencies, apenas por questão de organização. Porém, dessa vez, ele também é utilizado para criar os nós de nossa árvore de comportamento: As folhas playerWithinRange, safeHealth, offAttackCooldown, o inversor playerOutsideAtkRange, as sequências canAttackPlayer e a raíz, e o seletor pursueOrRun, conforme visto na figura X.
		
		Esse script não possui método Update, pois suas avaliações são executadas pelo Update do EnemyController. Assim, temos o método Evaluate, que verifica se o nó raíz já foi inicializado, e caso tenha, executa o próprio Evaluate pertencente ao nó. Isso faz com que todas as condições da árvore sejam testadas e atualiza o estado de cada nó pertencente a ela. Em seguida, chamamos o método ExecuteActions, que testa o estado de alguns nós e executa comandos de acordo com os resultados da avaliação.
		
		Caso o nó safeHealth falhe, ele executa o método RunAway, caso contrário, se o nó canAttackPlayer for um sucesso, executará o comando de ataque, caso contrário, se o nó playerOutsideAtkRange for um sucesso, ele perseguirá o jogador até estar dentro de seu alcance. Caso nenhuma das condições acima seja atendida, houve um problema na avaliação, e todas as ações serão interrompidas.
		
		Os métodos MoveTowardsPlayer, RunAway e AttackPlayer chamam seus equivalentes no script EnemyController, servindo apenas para gerar um tempo aleatório de atraso antes da execução do comando para aumentar um pouco a imprevisibilidade das ações, e tornar as ações menos robotizadas, passando a impressão de que a criatura está pensando antes de executar um comando, visto que todas as condições são avaliadas muito rapidamente para gerar qualquer tempo perceptível de espera entre a execução de diferentes ações.
		
		Os métodos WithinAtkRange, HealthSafeZone e AttackOffCooldown são validações utilizadas dentro de nós, e verificam, respectivamente, se o jogador está dentro do raio onde um ataque irá atingí-lo, se os pontos de vida da criatura são maiores do que 35% do total, e se o ataque dela já saiu do tempo de resfriamento, isso é, se o intervalo de tempo entre um golpe e outro já acabou.
		
		Para concluir a ideia da utilização da árvore, vamos observar os métodos Start e Update do script EnemyController. O método Start inicializa os componentes do objeto da criatura, inclusive o script SampleEnemyTree, que contém a lógica de tomada de decisões. O método Update é responsável por verificar os pontos de vida da criatura, e destruí-la quando eles chegam a zero. Além disso, ele chama a função Evaluate da SampleEnemyTree, que por sua vez fará a chamada dos métodos presentes nesse script com base no resultado dos nós.
		
		Entre eles, temos MoveTowardsPlayer, que verifica a posição da criatura em relação ao jogador, e se move na direção desejada para se aproximar dele, além de controlar as animações de movimento. O método RunAway faz a mesma verificação, porém, se move na direção oposta. AttackPlayer executa a chamada ao método AttackPlayerDelayed, para atrasar o momento em que o impacto com o jogador ocorre para se encaixar melhor na animação. Além disso, ele chama o método KnockbackPlayer, que empurra o jogador no momento do impacto. O método OnCollisionEnter2D é herdado de MonoBehaviour, e danifica e empurra o jogador, da mesma forma que um ataque o faria.
		
		O método TakeDamage é chamado pelo script do jogador PlayerAttack, e reduz os pontos de vida da criatura pelo dano emitido pelo jogador, além de emitir efeitos de particulas e escurecer brevemente o desenho da criatura, através da chamada do método DamageBlink.
		
		Os métodos GetCurrentHealth e GetCurrentCooldown retornam os valores de pontos de vida e tempo restante de resfriamento, respectivamente, e são usados apenas para consultar esses valores para tomada de decisões na árvore. Por fim, o método OnDrawGizmosSelected é usado com o mesmo propósito do script de ataque do jogador, que é exibir a área de efeito do golpe desferido pela criatura.
		
		Esses dois scripts interagem muito entre si, mas é importante que sejam segregados para que seus propósitos não sejam confundidos. Enquanto nada impede que se tornem um único arquivo, isso prejudica a organização do projeto.
		
		Por último, temos os três scripts responsáveis pela implementação da lógica de pathfinding através do algoritmo A* search: StarGrid, Pathfinding e PathRequestManager.
		
		Para percorrer determinado caminho em nossos cenários, precisamos elencar alguns pontos chave, para que se possa traçar uma rota. Isto é, por mais que tenhamos um plano que possa ser percorrido, precisamos dividi-lo de forma que seja possível mapear as coordenadas de cada área do jogo. Para isso, criamos uma grade com vários quadrados, que chamamos de nós, da mesma forma que chamamos cada "bloco" da árvore de comportamento. O script StarGrid é responsável por criar essa grade, implementando a classe Node.
		
		O script possui os métodos Awake, CreateGrid, NodeFromWorldPoint, NeighbourNodes e OnDrawGizmos. Para criar a grade, informamos o raio de cada nó e o tamanho da grade, em altura e largura, e o método Awake calcula o diâmetro de cada nó, a quantidade de nós verticalmente e lateralmente, e faz a chamada ao método CreateGrid. Esse, por sua vez, cria uma nova matriz de nós com base na quantidade calculada anteriormente. Uma matriz, nesse caso, é um termo matemático, que representa uma tabela com um número x de linhas e y de colunas, e pode ser utilizado com facilidade para representar cada nó de nossa grade.
		
		Ainda no método CreateGrid, é feita uma comparação com uma máscara para saber se os nós estão obstruídos ou não. Isso é feito com base em uma funcionalidade no Unity chamada LayerMask, que verifica quais áreas de determinada camada estão ocupadas. Assim, fazemos comparações com a área de cada nó com a área da máscara, e caso eles se sobreponham o nó está obstruído e não pode ser utilizado para calcular uma rota.
		
		O método OnDrawGizmos, herdado da classe MonoBehaviour, é utilizado para visualizarmos no editor da IDE a área de alcance da grade, é seu propósito é auxiliar a realização de ajustes.
		
		O método NodeFromWorldPoint é usado para buscar qual nó está em determinada posição, enquanto NeighbourNodes retorna uma lista de nós adjacentes a um nó específico. Sua utilização é essencial no script Pathfinding, pois precisamos de um meio fácil e rápido de localizar os nós de acordo com suas posições no cenário.
		
		Dentro do script finding, temos de fato a implementação do algoritmo propriamente dito. Ele possui os métodos Awake, FindPath, BuildPath, OptimizePath e GetDistance. Novamente, o Awake é utilizado para buscar os componentes, nesse caso, a grade e o PathRequestManager.
		
		O método FindPath é o que transforma o pseudocódigo apresentado anteriormente em código real. Ele pega a referência dos nós inicial e alvo, e insere o nó inicial na lista de nós abertos. À partir daí, faz um loop dentro de todos os nós abertos, e abre ou fecha os nós vizinhos de acordo com seus custos de movimentação. Assim que o nó comparado for igual ao nó de destino, o loop é interrompido, e o algoritmo retorna sucesso para o caminho encontrado. Caso não existam mais nós abertos e o nó de destino não foi encontrado, entende-se que o algoritmo não conseguiu encontrar um caminho viável, e é retornada uma falha. O caminho só é buscado caso o nó de destino não esteja obstruído. A cada vez que um nó é avaliado, seus vizinhos o recebem como nó pai, para permitir que o caminho de volta seja traçado no método BuildPath. 
		
		O método BuildPath cria uma lista de nós, acessando os pais de cada um até que o nó avaliado seja o mesmo onde a busca por um caminho foi iniciada. Ao final, é necessário reverter a ordem para obter o caminho correto, visto que avaliamos os nós de trás para frente.
		
		O método OptimizePath não é necessário, porém ele diminui a utilização de recursos. Ele compara vetores subsequentes e avalia se eles estão apontando na mesma direção e sentido, e caso esteja, remove o primeiro vetor, efetivamente mantendo o caminho percorrido, porém com menos etapas.
		
		O método GetDistance é utilizado para verificar a distância entre dois nós e calcular o custo de movimentação dentro do método FindPath.
		
		O método FindPath é requisitado através do script PathRequestManager, com o objetivo de enfileirar as solicitações de diversas criaturas, para que o sistema não fique sobrecarregado com diversas demandas simultaneas. Possui os métodos Awake, RequestPath, TryNexPath, AfterPathExecuted, e uma classe privada PathRequest para armazenar em uma lista de caminhos.
		
		O RequestPath insere o caminho solicitado em uma fila, e faz a chamada ao próximo caminho através do método TryNextPath. Esse, por sua vez, verifica se existe algum caminho sendo calculado. Se não houver, ele desenfilera a primeira solicitação  disponível e faz a chamada ao FindPath no script Pathfinding, e havendo sucesso faz a chamada ao método OnPathFound da OverworldEnemyController para percorrer o caminho encontrado. Em seguida, ele tenta calcular o próximo caminho da fila, e assim por diante.
		
		O desenvolvimento de um jogo em uma plataforma como o Unity traz uma série de facilidades na utilização, e nos poupa o esforço de tentar recriar recursos aos quais já temos acesso. Ainda que exista um valor no aprendizado da implementação de tais recursos, quando queremos atingir um resultado melhor, o uso desse tipo de ferramenta é essencial. Note que, mesmo com tudo o que é possível atingir com a simples utilização da ferramenta, ainda existem muitos recursos lógicos a serem implementados.
		
		Ainda que seja difícil utilizar a ferramenta em seu potencial máximo, e seja necessário investir algum tempo no aprendizado de seu manuseio, os resultados atingidos ainda acabam por gerar economia de tempo, e portanto, seu uso é vantajoso.
	</P>
	<SCRIPT>
		document.onload = function()
		{
			alert("Hey! Listen! Watch out!");
		};
	</SCRIPT>
</BODY>
</HTML>
